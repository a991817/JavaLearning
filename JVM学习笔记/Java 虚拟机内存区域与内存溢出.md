# Java 虚拟机内存区域与内存溢出

![内存区域](E:\Study-Workplaces\JVM学习笔记\jvmdata.png)

## 1、程序计数器

​	当线程在执行一个 **Java 方法**时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是 **Native 方法**（调用本地操作系统方法）时，该计数器的值为空。

​	另外，该内存区域是唯一一个在 Java 虚拟机规范中**没有**规定任何 OOM（内存溢出：OutOfMemoryError）情况的区域。

​	每条线程都有一个独立的的程序计数器

## 2、Java虚拟机栈

​	虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈是用于支持续虚拟机进行**方法调用**和**方法执行**的数据结构。

>  在**单线程**的操作中，虚拟机抛出的都是 **StackOverflowError 异常**
>
> 而在**多线程**环境下，则会抛出 **OutOfMemoryError 异常**。

### **栈帧中所存放的各部分信息的作用和数据结构**

#### 2.1 局部变量表

​	局部变量表是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）。

#### 2.2 操作数栈

​	操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。

> 基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；(Java虚拟机)
>
> 而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差；（Android 虚拟机）

#### 2.3 动态链接

​	每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

#### 2.4 方法返回地址

​	方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。

## 3、本地方法栈

​	该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

## 4、Java堆

​	Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

​	根据 Java 虚拟机规范的规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。

## 5、方法区

​	方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于 Sun HotSpot 来讲，JRockit 和 IBM J9 虚拟机中并不存在永久代的概念。

> Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入 Class 文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是 String 类的 intern（）方法。

## 6、直接内存

​	直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。

## 内存溢出的测试方法

![内存溢出的测试方法](E:\Study-Workplaces\JVM学习笔记\overflow.md.png)

## 内存泄漏和内存溢出的区别

​	内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java 中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们 new 了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露，

​	内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。

## 对象实例分析

对内存分配情况分析最常见的示例便是对象实例化:

```java
Object obj = new Object();
```

这段代码的执行会涉及 **Java 栈、Java 堆、方法区**三个最重要的内存区域。假设该语句出现在方法体中，及时对 JVM 虚拟机不了解的 Java 使用这，应该也知道 obj 会作为引用类型（reference）的数据保存在 Java 栈的本地变量表中，而会在 Java 堆中保存该引用的实例化对象，但可能并不知道，Java 堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。

另外，由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用**句柄池**和**直接使用指针**。

通过句柄池访问的方式如下：

![](E:\Study-Workplaces\JVM学习笔记\javastack.png)

通过直接指针访问的方式如下：

![](E:\Study-Workplaces\JVM学习笔记\javastack1.png)

这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是 reference 中存放的是**稳定的句柄地址**，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式的最大好处是**速度快**，它节省了一次指针定位的时间开销。目前 Java 默认使用的 HotSpot 虚拟机采用的便是是**第二种方式**进行对象访问的。